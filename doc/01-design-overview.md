# **Forge: Design and Specification**

## **1\. Vision & Mission**

**Forge** is a command-line interface (CLI) tool designed for the analysis and semantic indexing of large-scale, complex Fortran codebases. Its core mission is to transform unstructured source code into a structured, queryable **"semantic knowledge base"** stored within a relational database.

This tool is engineered for research scientists and software engineers who need to deeply understand, modernize, and perform automated analysis on legacy scientific computing software. It adopts the declarative philosophy of build automation tools like make: the user defines the *what* in a manifest file (forge.toml), and Forge handles the *how*, executing the pipeline efficiently, reliably, and reproducibly.

## **2\. Core Concepts**

Forge is built upon a few fundamental principles to manage the complexity of code analysis.

### **2.1. Stateful Management via Finite State Machine (FSM)**

The entire analysis process is modeled as a **Finite State Machine (FSM)**. A Forge project can only exist in one of a series of well-defined states at any given time (e.g., INITIALIZED, EXTRACTED, RESOLVED). Progress is made by executing CLI commands that transition the project from one state to the next. This approach makes the complex pipeline transparent, manageable, and easy to diagnose.

### **2.2. Declarative Configuration**

Users interact with Forge through a simple, human-readable TOML file: forge.toml. This file is the single source of truth for the project's scope. Users declare which directories contain source code and define exclusion rules, rather than writing complex scripts. This lowers the barrier to entry and makes project configurations easy to version-control and share.

### **2.3. Idempotency and Incrementality**

Forge tracks the state of every source file using content-based hashing (SHA256). An operation (like parsing a file) will only be re-executed if the source file has changed since the last run. This ensures that repeated commands have no side effects (**idempotency**) and that builds are fast, as only modified files are processed (**incrementality**).

## **3\. The Configuration File: forge.toml**

The forge.toml file is the heart of a Forge project. It's generated by the forge init command and is designed to be both powerful and easy to understand.

### **Structure Overview**

The configuration is organized into logical sections:

* `[project]`: High-level metadata about the project.  
* `[sources]`: Defines the scope of the source code to be analyzed.  
* `[parser]`: (Optional) Fine-tunes the behavior of the code parser.

### **Example forge.toml**

```toml
# forge.toml: The core configuration file for a Forge project.
# This template is generated by the `forge init` command.

[project]
# The name of the project, used in reports and database entries.
name = "CFD_Project_Typhoon"

# (Optional) A brief description of the project.
description = "A computational fluid dynamics model for typhoon simulation."

# (Optional) The Fortran standard the code adheres to.
# Used to guide parsing and future analyses. e.g., "F90", "F2003", "F2008".
fortran_standard = "F2008"


[sources]
# A list of directories containing source code, relative to this file.
source_dirs = [
    "src",
    "libs/solver",
    "commons"
]

# (Optional) A list of glob patterns to include files.
# If omitted, defaults to ["**/*.f90", "**/*.F90"].
include_patterns = [
    "**/*.f90",
    "**/*.F90",
    "**/*.inc"  # Also include header files
]

# (Optional) A list of glob patterns to exclude files or directories.
# These rules override the include_patterns.
exclude_patterns = [
    "**/*_test.f90",      # Exclude all test files
    "libs/solver/experimental/*" # Exclude an experimental directory
]


[parser]
# (Optional) The default encoding for source files.
encoding = "utf-8"

# (Optional) Whether symbol resolution should be case-sensitive.
# The Fortran standard is case-insensitive, but projects may have unique conventions.
case_sensitive = false


```

## **4\. The State Machine Model**

Forge tracks progress by transitioning the project through a series of states. The current state is persisted in the local state database (.forge/forge.sqlite3).

| State | Description | Key Artifacts | Trigger Command |
| :---- | :---- | :---- | :---- |
| **UNINITIALIZED** | A standard directory before Forge is involved. | None | forge init |
| **INITIALIZED** | The directory is recognized as a Forge project. | forge.toml, .forge/ dir | forge extract |
| **EXTRACTED** | All source files have been successfully parsed, and their Abstract Syntax Trees (ASTs) are saved locally. | Serialized AST files | forge transform |
| **TRANSFORMED** | The ASTs have been converted into structured JSON data representing symbols, calls, etc. | Serialized JSON files | forge load |
| **LOADED** | The structured JSON data has been loaded into the target relational database. | Populated DB tables | forge resolve |
| **RESOLVED** | Post-processing routines (e.g., symbol reference resolution) have been executed on the database. The knowledge base is complete and ready for queries. | Fully consistent DB | (Final State) |
| **FAILED** | An error occurred during any transition. The process is halted until the issue is resolved. | Error logs | (Manual Intervention) |

## **5\. Command-Line Interface (CLI) Workflow**

The forge CLI is the user's primary interface for driving the analysis pipeline.

### **1\. Initializing a Project**

First, navigate to your project's root directory and run init.

```shell
cd /path/to/your/fortran\_project  
forge init
```

This creates the forge.toml file and the .forge directory, transitioning the project to the INITIALIZED state. You should now edit forge.toml to define your source directories.

### **2\. Checking Project Status**

At any point, you can check the current state of the project.
```shell
forge status
```
**Expected Output:**
```shell
Project: CFD\_Project\_Typhoon  
Status: INITIALIZED  
Forge Version: 0.1.0  
Tracked Files: 0  
Last Updated: 2025-08-17 16:30:00 UTC
```

### **3\. Running the Pipeline**

You execute the analysis steps sequentially. Forge will prevent you from running a step out of order.

#### Step 1: Extract ASTs  
This command finds all source files, validates their hashes, and parses any new or modified files.  
```shell
forge extract
```
#### Step 2: Transform ASTs to JSON  
This step converts the low-level ASTs into a higher-level, structured JSON representation.  
```shell
forge transform
```

#### Step 3: Load Data into the Database  
This step pushes the generated JSON data into the target database specified by the URL.  
```shell
forge load --db-url "postgresql://user:pass@host/dbname"
```

#### Step 4: Resolve Symbols in the Database  
The final step performs post-processing within the database to link symbol uses to their declarations.  
```shell
forge resolve --db-url "postgresql://user:pass@host/dbname"

```

### **4\. Other Commands**

* **forge clean**: Removes all generated artifacts from the .forge directory and resets the project state, allowing for a fresh run.  
* **forge version**: Prints the installed version of the Forge CLI.